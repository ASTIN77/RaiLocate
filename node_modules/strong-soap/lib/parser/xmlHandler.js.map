{"version":3,"file":"xmlHandler.js","names":["_createForOfIteratorHelper","r","e","t","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","_n","F","s","n","done","value","f","TypeError","o","a","u","call","next","return","_arrayLikeToArray","toString","slice","constructor","name","from","test","xmlBuilder","require","sax","stream","assert","selectn","debug","descriptor","ElementDescriptor","AttributeDescriptor","TypeDescriptor","QName","helper","NamespaceContext","XMLHandler","schemas","options","valueKey","xmlKey","attributesKey","xsiTypeKey","date","timezone","enabled","jsonToXml","node","nsContext","val","begin","version","encoding","standalone","nameSpaceContextCreated","toXmlDateOrTime","qname","form","attribute","mapping","declareNamespace","prefix","nsURI","attrName","isSimple","attrs","isMany","i","element","elementName","xmlns","pushContext","getPrefixMapping","newlyDeclared","declared","replace","cdata","raw","enforceRestrictions","type","schema","simpleTypes","anonymous","restriction","enforce","isNillable","namespaces","xsi","addAttributes","popContext","p","child","refOriginal","typeDescriptor","inheritance","extension","elements","concat","Date","text","mapObject","undefined","getXsiType","xsiTypeDescriptor","xsiType","parse","xsiTypeInfo","complexTypes","describe","_sortKeys","elementOrder","compare","n1","n2","order","i1","indexOf","i2","keys","Object","names","sort","result","attributes","elementDescriptor","push","attributeDescriptor","attributeName","_iterator","_step","childDescriptor","ignoreUnknownProperties","err","attrDescriptors","createSOAPEnvelope","doc","create","header","body","createSOAPEnvelopeDescriptor","parameterDescriptor","envelopeDescriptor","addElement","headerDescriptor","bodyDescriptor","add","headers","faults","xsdStr","xsd","faultDescriptor","detailDescriptor","parseXml","root","xml","cb","parser","stringMode","opt","Readable","createStream","current","stack","onerror","process","nextTick","ontext","isDocument","trim","oncdata","onopentag","onclosetag","nsName","top","pop","onend","write","close","pipe","_processText","object","xmlToJson","self","refs","id","obj","elementAttributes","substring","addNamespace","isXsiType","xsiXmlns","getNamespaceURI","attrDescriptor","findAttribute","attrValue","parseValue","elementQName","href","substr","hrefs","parent","key","findElement","handleJsonObject","merge","j","hasOwnProperty","ref","Envelope","Body","Fault","errorMessage","getSoap11FaultErrorMessage","getSoap12FaultErrorMessage","error","Error","faultBody","faultcode","faultstring","faultactor","detail","JSON","stringify","code","subCode","reason","role","uri","jsType","dateText","Boolean","toXmlDate","isoStr","toISOString","formattedDate","split","withTimezone","toXmlTime","toXmlDateTime","module","exports"],"sources":["../../src/parser/xmlHandler.js"],"sourcesContent":["// Copyright IBM Corp. 2016,2019. All Rights Reserved.\n// Node module: strong-soap\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n'use strict';\n\nvar xmlBuilder = require('xmlbuilder');\nvar sax = require('sax');\nvar stream = require('stream');\nvar assert = require('assert');\nvar selectn = require('selectn');\nvar debug = require('debug')('strong-soap:xmlhandler');\nvar descriptor = require('./xsd/descriptor');\nvar ElementDescriptor = descriptor.ElementDescriptor;\nvar AttributeDescriptor = descriptor.AttributeDescriptor;\nvar TypeDescriptor = descriptor.TypeDescriptor;\nvar QName = require('./qname');\nvar helper = require('./helper');\nvar NamespaceContext = require('./nscontext');\n\n\nclass XMLHandler {\n  /**\n   * @param {Object} [schemas] \n   * @param {Object} [options]\n   * @param {boolean} [options.enforceRestrictions]\n   * @param {string} [options.valueKey]\n   * @param {string} [options.xmlKey]\n   * @param {string} [options.attributesKey]\n   * @param {string} [options.xsiTypeKey]\n   * @param {Object} [options.date]\n   * @param {Object} [options.date.timezone]\n   * @param {boolean} [options.date.timezone.enabled]\n   */\n  constructor(schemas, options) {\n    this.schemas = schemas || {};\n    this.options = options || {};\n    this.options.valueKey = this.options.valueKey || '$value';\n    this.options.xmlKey = this.options.xmlKey || '$xml';\n    this.options.attributesKey = this.options.attributesKey || '$attributes';\n    this.options.xsiTypeKey = this.options.xsiTypeKey || '$xsiType';\n    this.options.date = this.options.date || {};\n    this.options.date.timezone = this.options.date.timezone || {};\n    this.options.date.timezone.enabled = typeof this.options.date.timezone.enabled === 'boolean' ? this.options.date.timezone.enabled : true;\n  }\n\n  jsonToXml(node, nsContext, descriptor, val) {\n    if (node == null) {\n      node = xmlBuilder.begin(\n        {version: '1.0', encoding: 'UTF-8', standalone: true});\n    }\n    if (nsContext == null) {\n      nsContext = new NamespaceContext();\n    }\n\n    var name;\n    let nameSpaceContextCreated = false;\n    if (descriptor instanceof AttributeDescriptor) {\n      val = toXmlDateOrTime(descriptor, val, this.options.date);\n      name = descriptor.qname.name;\n      if (descriptor.form === 'unqualified') {\n        node.attribute(name, val);\n      } else if (descriptor.qname) {\n        let mapping = declareNamespace(nsContext, node, descriptor.qname.prefix,\n          descriptor.qname.nsURI);\n        let prefix = mapping ? mapping.prefix : descriptor.qname.prefix;\n        let attrName = prefix ? prefix + ':' + name : name;\n        node.attribute(attrName, val);\n      }\n      return node;\n    }\n\n    if (descriptor instanceof ElementDescriptor) {\n      name = descriptor.qname.name;\n      let isSimple = descriptor.isSimple;\n      let attrs = null;\n      if (descriptor.isMany) {\n        if (Array.isArray(val)) {\n          for (let i = 0, n = val.length; i < n; i++) {\n            node = this.jsonToXml(node, nsContext, descriptor, val[i]);\n          }\n          return node;\n        }\n      }\n      if(val !== null && typeof val === \"object\"){\n        // check for $attributes field\n        if (typeof val[this.options.attributesKey] !== \"undefined\"){\n          attrs = val[this.options.attributesKey];\n        }\n        // add any $value field as xml element value\n        if (typeof val[this.options.valueKey] !== \"undefined\"){\n          val = val[this.options.valueKey];\n        }\n      }\n      let element;\n      let elementName;\n      let xmlns;\n      if (descriptor.form === 'unqualified') {\n        elementName = name;\n        nsContext.pushContext();\n        nameSpaceContextCreated = true;\n      } else if (descriptor.qname) {\n        nsContext.pushContext();\n        nameSpaceContextCreated = true;\n        // get the mapping for the namespace uri\n        let mapping = nsContext.getPrefixMapping(descriptor.qname.nsURI);\n        let newlyDeclared = false;\n        // if namespace not declared, declare it\n        if (mapping === null || mapping.declared === false) {\n          newlyDeclared = true;\n          mapping = declareNamespace(nsContext, null,\n          descriptor.qname.prefix, descriptor.qname.nsURI);\n        }\n        // add the element to a parent node\n        let prefix = mapping ? mapping.prefix : descriptor.qname.prefix;\n        elementName = prefix ? prefix + ':' + name : name;\n        // if namespace is newly declared add the xmlns attribute\n        if (newlyDeclared) {\n          xmlns = prefix ? 'xmlns:' + prefix : 'xmlns';\n        }\n      }\n\n      // add the element to a parent node\n      if (isSimple && /<!\\[CDATA/.test(val)) {\n        element = node.element(elementName);\n        val = val.replace(\"<![CDATA[\",\"\");\n        val = val.replace(\"]]>\",\"\");\n        element.cdata(val);\n      }else if(isSimple && typeof val !== \"undefined\" && val !== null\n        && typeof val[this.options.xmlKey] !== \"undefined\") {\n        val = val[this.options.xmlKey];\n        element = node.element(elementName);\n        val = toXmlDateOrTime(descriptor, val, this.options.date);\n        element.raw(val);\n      } else {\n        // Enforce the type restrictions if configured for such\n        if (this.options.enforceRestrictions && descriptor.type) {\n          const schema = this.schemas[descriptor.type.nsURI];\n          if (schema) {\n            let type = schema.simpleTypes[descriptor.type.name];\n            // if type not available in global schema\n            // , check if it is embedded in descriptor as an anonymous type\n            if (!type && descriptor.type.anonymous) {\n              type = descriptor.type.anonymous;\n            }\n            if (type) {\n              const restriction = type.restriction;\n              if (restriction) {\n                val = restriction.enforce(val);\n              }\n            }\n          }\n        }\n        val = toXmlDateOrTime(descriptor, val, this.options.date);\n        element = isSimple ? node.element(elementName, val) : node.element(elementName);\n      }\n\n      if (xmlns && descriptor.qname.nsURI) {\n        if (typeof element.attribute === 'function') {\n          element.attribute(xmlns, descriptor.qname.nsURI);\n        }\n      }\n\n      if (val == null) {\n        if (descriptor.isNillable) {\n          // Set xsi:nil = true\n          declareNamespace(nsContext, element, 'xsi', helper.namespaces.xsi);\n          if (typeof element.attribute === 'function') {\n            element.attribute('xsi:nil', true);\n          }\n        }\n      }\n\n      if (isSimple) {\n        if (attrs !== null) {\n          // add each field in $attributes object as xml element attribute\n          if (typeof attrs === \"object\") {\n            //add $attributes. Attribute can be an attribute defined in XSD or an xsi:type\n            this.addAttributes(element, nsContext, descriptor, val, attrs);\n          }\n        }\n        if (nameSpaceContextCreated) {\n          nsContext.popContext();\n        }\n        return node;\n      } else if ( val != null) {\n\n        let attrs = val[this.options.attributesKey];\n        if (typeof attrs === 'object') {\n          for (let p in attrs) {\n            let child = attrs[p];\n            if (p === this.options.xsiTypeKey) {\n              if (descriptor instanceof ElementDescriptor) {\n                if (descriptor.refOriginal) {\n                  if (descriptor.refOriginal.typeDescriptor) {\n                    if (descriptor.refOriginal.typeDescriptor.inheritance){\n                      let extension = descriptor.refOriginal.typeDescriptor.inheritance[child.type];\n                      if (extension) {\n                        descriptor.elements = descriptor.elements.concat(extension.elements);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      //val is not an object - simple or date types\n      if (val != null && ( typeof val !== 'object' || val instanceof Date)) {\n        // for adding a field value nsContext.popContext() shouldnt be called\n        val = toXmlDateOrTime(descriptor, val, this.options.date);\n        element.text(val);\n        //add $attributes. Attribute can be an attribute defined in XSD or an xsi:type.\n        //e.g of xsi:type <name xmlns=\"..\" xmlns:xsi=\"...\" xmlns:ns=\"...\" xsi:type=\"ns:string\">some name</name>\n        if (attrs != null) {\n          this.addAttributes(element, nsContext, descriptor, val, attrs);\n        }\n        if (nameSpaceContextCreated) {\n          nsContext.popContext();\n        }\n        return node;\n      }\n\n      this.mapObject(element, nsContext, descriptor, val, attrs);\n      if (nameSpaceContextCreated) {\n        nsContext.popContext();\n      }\n      return node;\n    }\n\n    if (descriptor == null  || descriptor === undefined || descriptor instanceof TypeDescriptor) {\n      this.mapObject(node, nsContext, descriptor, val);\n      return node;\n    }\n\n    return node;\n  }\n\n  /**\n   * Check if the attributes have xsi:type and return the xsi type descriptor if exists\n   * @param {*} descriptor The current descriptor\n   * @param {*} attrs An object of attribute values\n   */\n  getXsiType(descriptor, attrs) {\n    var xsiTypeDescriptor;\n    if (attrs != null && typeof attrs === \"object\") {\n      for (let p in attrs) {\n        let child = attrs[p];\n        // if field is $xsiType add xsi:type attribute\n        if (p === this.options.xsiTypeKey) {\n          let xsiType;\n          if (typeof child === \"object\" && typeof child.type !== \"undefined\") {\n            // $xsiType has two fields - type, xmlns\n            xsiType = QName.parse(child.type, child.xmlns);\n          } else {\n            xsiType = QName.parse(child);\n          }\n          var schema = this.schemas[xsiType.nsURI];\n          if (schema) {\n            var xsiTypeInfo =\n              schema.complexTypes[xsiType.name] ||\n              schema.simpleTypes[xsiType.name];\n            // The type might not be described\n            // describe() takes wsdl definitions\n            xsiTypeDescriptor = xsiTypeInfo && xsiTypeInfo.describe({schemas: this.schemas});\n          }\n          break;\n        }\n      }\n    }\n    return xsiTypeDescriptor;\n  }\n\n  _sortKeys(val, elementOrder) {\n    function compare(n1, n2, order) {\n      let i1 = order.indexOf(n1);\n      if (i1 === -1) i1 = order.length;\n      let i2 = order.indexOf(n2);\n      if (i2 === -1) i2 = order.length;\n      return i1 - i2;\n    }\n    const keys = Object.keys(val);\n    var names = [].concat(keys).sort((n1, n2) => {\n      let result = compare(n1, n2, elementOrder);\n      if (result ===0) {\n        result = compare(n1, n2, keys);\n      }\n      return result;\n    });\n    return names;\n  }\n\n  /**\n   * Map a JSON object into an XML type\n   * @param {XMLElement} node The root node\n   * @param {NamespaceContext} nsContext Namespace context\n   * @param {TypeDescriptor|ElementDescriptor} descriptor\n   * @param {Object} val\n   * @returns {*}\n   */\n  mapObject(node, nsContext, descriptor, val, attrs) {\n    if (val == null) return node;\n    if (typeof val !== 'object' || (val instanceof Date)) {\n      val = toXmlDateOrTime(descriptor, val, this.options.date);\n      node.text(val);\n      return node;\n    }\n\n    // First try to see if a subtype should be used\n    var xsiType = this.getXsiType(descriptor, attrs);\n    descriptor = xsiType || descriptor;\n\n    var elements = {}, attributes = {};\n    var elementOrder = [];\n    if (descriptor != null) {\n      for (let i = 0, n = descriptor.elements.length; i < n; i++) {\n        let elementDescriptor = descriptor.elements[i];\n        let elementName = elementDescriptor.qname.name;\n        elements[elementName] = elementDescriptor;\n        elementOrder.push(elementName);\n      }\n    }\n\n    if (descriptor != null) {\n      for (let a in descriptor.attributes) {\n        let attributeDescriptor = descriptor.attributes[a];\n        let attributeName = attributeDescriptor.qname.name;\n        attributes[attributeName] = attributeDescriptor;\n      }\n    }\n\n    // handle later if value is an array\n    if (!Array.isArray(val)) {\n      const names = this._sortKeys(val, elementOrder);\n      for (let p of names) {\n        if (p === this.options.attributesKey)\n          continue;\n\t      let child = val[p];\n\t      let childDescriptor = elements[p] || attributes[p];\n\t      if (childDescriptor == null) {\n\t        if (this.options.ignoreUnknownProperties)\n            continue;\n          else\n            childDescriptor = new ElementDescriptor(\n              QName.parse(p), null, 'unqualified', Array.isArray(child));\n        }\n        if (childDescriptor) {\n          this.jsonToXml(node, nsContext, childDescriptor, child);\n        }\n\t    }\n    }\n\n    this.addAttributes(node, nsContext, descriptor, val, attrs);\n\n    return node;\n  }\n\n  addAttributes(node, nsContext, descriptor, val, attrs) {\n    var attrDescriptors = (descriptor && descriptor.attributes) || [];\n    var attributes = {};\n    for (var i = 0; i < attrDescriptors.length; i++) {\n      var qname = attrDescriptors[i].qname;\n      attributes[qname.name] = attrDescriptors[i];\n    }\n    if (attrs != null && typeof attrs === 'object') {\n      for (let p in attrs) {\n        let child = attrs[p];\n        // if field is $xsiType add xsi:type attribute\n        if (p === this.options.xsiTypeKey) {\n          let xsiType;\n          if(typeof child === 'object' && typeof child.type !== 'undefined') {\n            // $xsiType has two fields - type, xmlns\n            xsiType = QName.parse(child.type, child.xmlns);\n          } else {\n            xsiType = QName.parse(child);\n          }\n          declareNamespace(nsContext, node, 'xsi', helper.namespaces.xsi);\n          let mapping = declareNamespace(nsContext, node, xsiType.prefix,\n            xsiType.nsURI);\n          let prefix = mapping ? mapping.prefix : xsiType.prefix;\n          node.attribute('xsi:type', prefix ? prefix + ':' + xsiType.name :\n            xsiType.name);\n          continue;\n        }\n        let childDescriptor = attributes[p];\n        if (childDescriptor == null) {\n          if (this.options.ignoreUnknownProperties) continue;\n          else {\n            childDescriptor =\n              new AttributeDescriptor(QName.parse(p), null, 'unqualified');\n          }\n        }\n        this.jsonToXml(node, nsContext, childDescriptor, child);\n      }\n    }\n  }\n\n  static createSOAPEnvelope(prefix, nsURI) {\n    prefix = prefix || 'soap';\n    var doc = xmlBuilder.create(prefix + ':Envelope',\n      {version: '1.0', encoding: 'UTF-8', standalone: true});\n    nsURI = nsURI || 'http://schemas.xmlsoap.org/soap/envelope/';\n    doc.attribute('xmlns:' + prefix,\n      nsURI);\n    let header = doc.element(prefix + ':Header');\n    let body = doc.element(prefix + ':Body');\n    return {\n      body: body,\n      header: header,\n      doc: doc\n    };\n  }\n\n  static createSOAPEnvelopeDescriptor(prefix, nsURI, parameterDescriptor) {\n    prefix = prefix || 'soap';\n    nsURI = nsURI || 'http://schemas.xmlsoap.org/soap/envelope/';\n    var descriptor = new TypeDescriptor();\n\n    var envelopeDescriptor = new ElementDescriptor(\n      new QName(nsURI, 'Envelope', prefix), null, 'qualified', false);\n    descriptor.addElement(envelopeDescriptor);\n\n    var headerDescriptor = new ElementDescriptor(\n      new QName(nsURI, 'Header', prefix), null, 'qualified', false);\n\n    var bodyDescriptor = new ElementDescriptor(\n      new QName(nsURI, 'Body', prefix), null, 'qualified', false);\n\n    envelopeDescriptor.addElement(headerDescriptor);\n    envelopeDescriptor.addElement(bodyDescriptor);\n\n    if (parameterDescriptor && parameterDescriptor.body) {\n      bodyDescriptor.add(parameterDescriptor.body);\n    }\n\n    if (parameterDescriptor && parameterDescriptor.headers) {\n      bodyDescriptor.add(parameterDescriptor.headers);\n    }\n\n    if (parameterDescriptor && parameterDescriptor.faults) {\n      var xsdStr = new QName(helper.namespaces.xsd, 'string', 'xsd');\n      var faultDescriptor = new ElementDescriptor(\n        new QName(nsURI, 'Fault', prefix), null, 'qualified', false);\n      faultDescriptor.addElement(\n        new ElementDescriptor(nsURI, 'faultcode', xsdStr, 'qualified', false));\n      faultDescriptor.addElement(\n        new ElementDescriptor(nsURI, 'faultstring', xsdStr, 'qualified', false));\n      faultDescriptor.addElement(\n        new ElementDescriptor(nsURI, 'faultactor', xsdStr, 'qualified', false));\n      var detailDescriptor =\n        new ElementDescriptor(nsURI, 'detail', null, 'qualified', false);\n      faultDescriptor.addElement(detailDescriptor);\n\n      for (var f in parameterDescriptor.faults) {\n        detailDescriptor.add(parameterDescriptor.faults[f]);\n      }\n    }\n\n    return descriptor;\n  }\n\n  /**\n   * Parse XML string or stream into the XMLBuilder tree\n   * @param root The root node\n   * @param xml XML string or stream\n   * @param cb\n   * @returns {*}\n   */\n  static parseXml(root, xml, cb) {\n    let parser;\n    let stringMode = true;\n    debug('XMLHandler parseXML. root: %j xml: %j', root, xml);\n    if (typeof xml === 'string') {\n      stringMode = true;\n      parser = sax.parser(true, {opt: {xmlns: true}});\n    } else if (xml instanceof stream.Readable) {\n      stringMode = false;\n      parser = sax.createStream(true, {opt: {xmlns: true}});\n    }\n    if (!root) {\n      root = xmlBuilder.begin();\n    }\n    let current = root;\n    let stack = [root];\n\n    parser.onerror = function(e) {\n      // an error happened.\n      if (cb) process.nextTick(cb);\n    };\n\n    parser.ontext = function(text) {\n      // got some text.  t is the string of text.\n      if (current.isDocument) return;\n      text = text.trim();\n      if (text) {\n        current.text(text);\n      }\n    };\n\n    parser.oncdata = function(text) {\n      if (current.isDocument) return;\n      text = text.trim();\n      if (text) {\n        current.cdata(text);\n      }\n    };\n\n    parser.onopentag = function(node) {\n      // opened a tag.  node has \"name\" and \"attributes\"\n      let element = current.element(node.name);\n      if (node.attributes) {\n        element.attribute(node.attributes);\n      }\n      stack.push(element);\n      current = element;\n    };\n\n    parser.onclosetag = function(nsName) {\n      var top = stack.pop();\n      assert(top === current);\n      assert(top.name === nsName);\n      current = stack[stack.length - 1];\n    };\n\n    parser.onend = function() {\n      if (cb) process.nextTick(function() {\n        // parser stream is done, and ready to have more stuff written to it.\n        cb && cb(null, root);\n      });\n    };\n\n    if (stringMode) {\n      parser.write(xml).close();\n    } else {\n      xml.pipe(parser);\n    }\n    return root;\n  }\n\n  _processText(top, val) {\n    // The parent element has xsi:nil = true\n    if (top.object === null) return;\n    // Top object has no other elements or attributes\n    if (top.object === undefined) {\n      top.object = val;\n    } else if (top.object.constructor === Object) {\n      // Top object already has attributes or elements\n      let value = top.object[this.options.valueKey];\n      if (value !== undefined) {\n        top.object[this.options.valueKey] = value + val;\n      } else {\n        top.object[this.options.valueKey] = val;\n      }\n    } else {\n      // Top object is other simple types, such as string or date\n      top.object = top.object + val;\n    }\n  }\n\n  xmlToJson(nsContext, xml, descriptor) {\n    var self = this;\n    var p = sax.parser(true);\n    nsContext = nsContext || new NamespaceContext();\n    var root = {};\n    var refs = {}, id; // {id: {hrefs:[], obj:}, ...}\n    var stack = [{name: null, object: root, descriptor: descriptor}];\n    var options = this.options;\n\n    p.onopentag = function(node) {\n      nsContext.pushContext();\n      var top = stack[stack.length - 1];\n      var descriptor = top.descriptor;\n      var nsName = node.name;\n      var attrs = node.attributes;\n      var obj = undefined;\n      var elementAttributes = null;\n\n      // Register namespaces 1st\n      for (let a in attrs) {\n        if (/^xmlns:|^xmlns$/.test(a)) {\n          let prefix = (a === 'xmlns') ? '' : a.substring(6);\n          nsContext.addNamespace(prefix, attrs[a]);\n        }\n      }\n\n      // Handle regular attributes\n      for (let a in attrs) {\n        if (/^xmlns:|^xmlns$/.test(a)) continue;\n        let qname = QName.parse(a);\n        var isXsiType = false;\n        var xsiType = null;\n        var xsiXmlns = null;\n        if (nsContext.getNamespaceURI(qname.prefix) === helper.namespaces.xsi) {\n          // Handle xsi:*\n          if (qname.name == 'nil') {\n            // xsi:nil\n            if (attrs[a] === 'true') {\n              obj = null;\n            }\n            continue;\n          } else if (qname.name === 'type') {\n            // xsi:type\n            isXsiType = true;\n            xsiType = attrs[a];\n            xsiType = QName.parse(xsiType);\n            attrs[a] = xsiType.name;\n            if(xsiType.prefix){\n              xsiXmlns = nsContext.getNamespaceURI(xsiType.prefix);\n            }\n          }\n        }\n        let attrName = qname.name;\n        elementAttributes = elementAttributes || {};\n        let attrDescriptor = descriptor && descriptor.findAttribute(qname.name);\n        let attrValue = parseValue(attrs[a], attrDescriptor);\n        // if element attribute is xsi:type add $xsiType field\n        if (isXsiType) {\n          // $xsiType object has two fields - type and xmlns\n          xsiType = {};\n          xsiType.type = attrs[a];\n          xsiType.xmlns = xsiXmlns;\n          elementAttributes[options.xsiTypeKey] = xsiType;\n        } else {\n          elementAttributes[attrName] = attrs[a];\n        }\n      }\n\n      if (elementAttributes) {\n        obj = {};\n        obj[self.options.attributesKey] = elementAttributes;\n      }\n\n      var elementQName = QName.parse(nsName);\n      elementQName.nsURI = nsContext.getNamespaceURI(elementQName.prefix);\n\n      // SOAP href (#id)\n      if (attrs.href != null) {\n        id = attrs.href.substr(1);\n        if (refs[id] === undefined) {\n          refs[id] = {hrefs: [], object: null};\n        }\n        refs[id].hrefs.push({\n          parent: top.object, key: elementQName.name, object: obj\n        });\n      }\n      id = attrs.id;\n      if (id != null) {\n        if (refs[id] === undefined)\n          refs[id] = {hrefs: [], object: null};\n      }\n\n      stack.push({\n        name: elementQName.name,\n        object: obj,\n        descriptor: descriptor && descriptor.findElement(elementQName.name),\n        id: attrs.id,\n      });\n    };\n\n    p.onclosetag = function(nsName) {\n      var elementName = QName.parse(nsName).name;\n      nsContext.popContext();\n      var current = stack.pop();\n      var top = stack[stack.length - 1];\n      if (top.object === undefined) {\n        top.object = {};\n      }\n      if (top.object !== null) {\n        if (typeof top.object === 'object' && elementName in top.object) {\n          // The element exist already, let's create an array\n          let val = top.object[elementName];\n          if (Array.isArray(val)) {\n            // Add to the existing array\n            val.push(current.object);\n          } else {\n            // Convert the element value to an array\n            top.object[elementName] = [val, current.object];\n          }\n        } else {\n          if (current.descriptor && current.descriptor.isMany) {\n            top.object[elementName] = [current.object];\n          } else {\n            top.object[elementName] = current.object;\n          }\n        }\n      }\n      if (current.id != null) {\n        refs[current.id].object = current.object;\n      }\n    };\n\n    p.oncdata = function(text) {\n      text = text && text.trim();\n      if (!text.length)\n        return;\n\n      if (/<\\?xml[\\s\\S]+\\?>/.test(text)) {\n        text = self.xmlToJson(null, text);\n      }\n      // add contents of CDATA to the xml output as a text\n      p.handleJsonObject(text);\n    };\n\n    p.handleJsonObject = function(text) {\n      var top = stack[stack.length - 1];\n      self._processText(top, text);\n    };\n\n    p.ontext = function(text) {\n      text = text && text.trim();\n      if (!text.length)\n        return;\n\n      var top = stack[stack.length - 1];\n      var descriptor = top.descriptor;\n      var value = parseValue(text, descriptor);\n      self._processText(top, value);\n    };\n\n    p.write(xml).close();\n\n    // merge obj with href\n    var merge = function(href, obj) {\n      for (var j in obj) {\n        if (obj.hasOwnProperty(j)) {\n          href.object[j] = obj[j];\n        }\n      }\n    };\n\n    // MultiRef support: merge objects instead of replacing\n    for (let n in refs) {\n      var ref = refs[n];\n      for (var i = 0; i < ref.hrefs.length; i++) {\n        merge(ref.hrefs[i], ref.object);\n      }\n    }\n\n    if (root.Envelope) {\n      var body = root.Envelope.Body;\n      if (root.Envelope.Body !== undefined && root.Envelope.Body !== null) {\n        if (body.Fault !== undefined && body.Fault !== null) {\n          //check if fault is soap 1.1 fault\n          var errorMessage = getSoap11FaultErrorMessage(body.Fault);\n          //check if fault is soap 1.2 fault\n          if (errorMessage == null) {\n            errorMessage = getSoap12FaultErrorMessage(body.Fault);\n          }\n          //couldn't process error message for neither soap 1.1 nor soap 1.2 fault. Nothing else can be done at this point. Send a generic error message.\n          if (errorMessage == null) {\n            errorMessage = 'Error occurred processing Fault response.';\n          }\n          var error = new Error(errorMessage);\n          error.root = root;\n          throw error;\n        }\n      }\n      return root.Envelope;\n    }\n    return root;\n  }\n\n}\n\nfunction getSoap11FaultErrorMessage(faultBody) {\n  var errorMessage = null;\n  var faultcode = selectn('faultcode.$value', faultBody)||\n    selectn('faultcode', faultBody);\n  if (faultcode) { //soap 1.1 fault\n    errorMessage = ' ';\n    //All of the soap 1.1 fault elements should contain string value except detail element which may be a complex type or plain text (string)\n    if (typeof faultcode == 'string') {\n      errorMessage =  'faultcode: ' + faultcode;\n    }\n    var faultstring = selectn('faultstring.$value', faultBody) ||\n      selectn('faultstring', faultBody);\n    if (faultstring && (typeof faultstring == 'string')) {\n      errorMessage = errorMessage + ' faultstring: ' + faultstring;\n    }\n    var faultactor = selectn('faultactor.$value', faultBody) ||\n      selectn('faultactor', faultBody);\n    if (faultactor && (typeof faultactor == 'string')) {\n      errorMessage = errorMessage + ' faultactor: ' + faultactor;\n    }\n    var detail = selectn('detail.$value', faultBody) ||\n      selectn('detail', faultBody);\n    if (detail != null) {\n      if (typeof detail == 'string') { //plain text\n        errorMessage = errorMessage + ' detail: ' + detail;\n      } else { //XML type defined in wsdl\n        errorMessage = errorMessage + ' detail: ' + JSON.stringify(detail);\n      }\n    }\n  }\n  return errorMessage;\n}\n\nfunction getSoap12FaultErrorMessage(faultBody) {\n  var errorMessage = null;\n  let code = selectn('Code', faultBody)||\n    selectn('Code', faultBody);\n  if (code) {\n    //soap 1.2 fault elements have child elements. Hence use JSON.stringify to formulate the error message.\n    errorMessage = ' ';\n    errorMessage = errorMessage + 'Code: ' + JSON.stringify(code);\n    var value = selectn('Value.$value', faultBody) ||\n      selectn('Value', faultBody);\n    if (value) {\n      errorMessage = errorMessage + ' ' + 'Value: ' + JSON.stringify(value);\n    }\n    var subCode = selectn('Subcode.$value', faultBody) ||\n      selectn('Subcode', faultBody);\n    if (subCode) {\n      errorMessage = errorMessage + ' ' + 'Subcode: ' + JSON.stringify(subCode);\n    }\n    var reason = selectn('reason.$value', faultBody) ||\n      selectn('Reason', faultBody);\n    if (reason) {\n      errorMessage = errorMessage + ' ' + 'Reason: ' + JSON.stringify(reason);\n    }\n    var node = selectn('Node.$value', faultBody) ||\n      selectn('Node', faultBody);\n    if (node) {\n      errorMessage = errorMessage + ' ' + 'Node: ' + JSON.stringify(node);\n    }\n    var role = selectn('Role.$value', faultBody) ||\n      selectn('Role', faultBody);\n    if (role) {\n      errorMessage = errorMessage + ' ' + 'Role: ' + JSON.stringify(role);\n    }\n    var detail = selectn('Detail.$value', faultBody) ||\n      selectn('Detail', faultBody);\n    if (detail != null) {\n      if (typeof detail == 'string') { //plain text\n        errorMessage = errorMessage + ' Detail: ' + detail;\n      } else { //XML type defined in wsdl\n        errorMessage = errorMessage + ' Detail: ' + JSON.stringify(detail);\n      }\n    }\n  }\n  return errorMessage;\n}\n\n\nfunction declareNamespace(nsContext, node, prefix, nsURI) {\n  var mapping = nsContext.declareNamespace(prefix, nsURI);\n  if (!mapping) {\n    return false;\n  } else if (node) {\n    if (typeof node.attribute === 'function') {\n      // Some types of node such as XMLDummy does not allow attribute\n      node.attribute('xmlns:' + mapping.prefix, mapping.uri);\n    }\n    return mapping;\n  }\n  return mapping;\n}\n\nfunction parseValue(text, descriptor) {\n  if (typeof text !== 'string') return text;\n  var value = text;\n  var jsType = descriptor && descriptor.jsType;\n  if (jsType === Date) {\n    var dateText = text;\n    // Checks for xs:date with tz, drops the tz \n    // because xs:date doesn't have a time to offset\n    // and JS Date object doesn't store an arbitrary tz\n    if(dateText.length === 16){\n      dateText = text.substr(0, 10);\n    }\n    value = new Date(dateText);\n  } else if (jsType === Boolean) {\n    if (text === 'true' || text === '1') {\n      value = true;\n    } else {\n      value = false;\n    }\n  } else if (typeof jsType === 'function') {\n    value = jsType(text);\n  }\n  return value;\n}\n\n/**\n * \n * @param {string | Date} date \n * @param {Object} [options] \n * @param {Object} [options.timezone]\n * @param {boolean} [options.timezone.enabled]\n * @returns \n */\nfunction toXmlDate(date, options) {\n  try {\n    const isoStr = new Date(date).toISOString();\n    const formattedDate = isoStr.split('T')[0];\n    const withTimezone = (options && options.timezone) && typeof options.timezone.enabled === 'boolean' ? options.timezone.enabled : true;\n    if (!withTimezone) {\n      return formattedDate;\n    }\n    return formattedDate + 'Z';  \n  } catch (err) {\n    return date;\n  }\n}\n\nfunction toXmlTime(date) {\n  try {\n    const isoStr = new Date(date).toISOString();\n    return isoStr.split('T')[1];  \n  } catch (err) {\n    return date;\n  }\n}\n\nfunction toXmlDateTime(date) {\n  try {\n    return new Date(date).toISOString();  \n  } catch (err) {\n    return date; \n  }\n}\n\n/**\n * \n * @param {object} descriptor \n * @param {* | null} val \n * @param {Object} options\n * @param {Object} options.timezone\n * @param {boolean} options.timezone.enabled\n * @returns {string}\n */\nfunction toXmlDateOrTime(descriptor, val, options) {\n  if (!descriptor || !descriptor.type || val === null) return val;\n  if (descriptor.type.name === 'date') {\n    return toXmlDate(val, options);\n  } else if (descriptor.type.name === 'time') {\n    return toXmlTime(val);\n  } else if (descriptor.type.name === 'dateTime') {\n    return toXmlDateTime(val);\n  }\n  return val;\n}\n\nmodule.exports = XMLHandler;\n\n// Exported function for testing\nmodule.exports.parseValue = parseValue;\nmodule.exports.toXmlDate = toXmlDate;\nmodule.exports.toXmlTime = toXmlTime;\nmodule.exports.toXmlDateTime = toXmlDateTime;\n"],"mappings":"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","ignoreList":[]}